attribute vec2 reference;//需要配合gpgpu使用
attribute float birdVertex;

attribute vec3 birdColor;
//attribute vec3 position;属于基础attribute所以被省略了

uniform vec3 texturePosition;//这里先不用gpgpu
uniform vec3 textureVelociry;
uniform float birdWing;
uniform int birds;

uniform float time;

varying vec4 vColor;
varying float z;

void main(){
    //vec4 tempPos = vec4( texturePosition.xyz, 0);
    vec3 pos = texturePosition;
    vec3 velocity = normalize(textureVelociry);

    vec3 newPosition = position;
    if(birdVertex == 4.0 || birdVertex == 7.0){
        //flap wings
        newPosition.y = sin(birdWing) * 5.0;
    }

    newPosition = mat3(modelMatrix) * newPosition;//用模型自身的变化矩阵来计算

    velocity.z *= -1.0;//运动方向z轴翻转？

    //以下要做的是，通过两次旋转，将面朝某个方向的鸟儿，朝着面向velocity的方向变化。
    //为了方便理解，请自行画一个图，，还记的鸟儿的点数据中，头部朝向吗，（z正轴）
    //然后，作者罪恶的做了一个y轴90度旋转，，，面向x轴负轴
    //现在，我们要用两个旋转矩阵，将z正轴 变化到velocity的方向，第一次，我们在
    //xy明面，做一次绕z轴的旋转，使朝向和xz平面的夹角和velocity相同
    float sinrz = velocity.y / 1.0;
    float cosrz = sqrt( 1.0 - velocity.y * velocity.y ) / 1.0;
    mat3 rotatez = mat3(
        cosrz, sinrz, 0,
        -sinrz,cosrz, 0,
        0,     0,     1
    );
    //之后绕y轴旋转一个角度，使朝向和velocity完全相同
    float xz = length(velocity.xz);
    float sinry = velocity.x / xz;
    float cosry = - 1.0 * velocity.z / xz;//这里不要忘了我们朝向的是x负轴噢，(z是负的是这么来的)
    mat3 rotatey = mat3(
        cosry, 0, -sinry,
        0    , 1, 0     ,
        sinry, 0, cosry
    );

    newPosition = rotatey * rotatez * newPosition;
    newPosition += pos;//newPosition没有描述位移，这里的pos类似于translate

    z = newPosition.z;//越远的颜色越浅

    vColor = vec4(birdColor, 1.0);
    gl_Position = projectionMatrix * viewMatrix * vec4(newPosition, 1.0);
}